(function () { const o = document.createElement("link").relList; if (o && o.supports && o.supports("modulepreload")) return; for (const s of document.querySelectorAll('link[rel="modulepreload"]')) n(s); new MutationObserver(s => { for (const r of s) if (r.type === "childList") for (const c of r.addedNodes) c.tagName === "LINK" && c.rel === "modulepreload" && n(c) }).observe(document, { childList: !0, subtree: !0 }); function t(s) { const r = {}; return s.integrity && (r.integrity = s.integrity), s.referrerPolicy && (r.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? r.credentials = "include" : s.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r } function n(s) { if (s.ep) return; s.ep = !0; const r = t(s); fetch(s.href, r) } })(); const H = Math.PI * 2, B = document.getElementById("game"), l = B.getContext("2d"); let k = B.width = window.innerWidth, j = B.height = window.innerHeight; window.addEventListener("resize", () => { k = B.width = window.innerWidth, j = B.height = window.innerHeight }); const y = { scoreEl: document.getElementById("score"), fpsEl: document.getElementById("fps"), lbEl: document.getElementById("leaderboard"), joinEl: document.getElementById("join"), playBtn: document.getElementById("play"), nameInput: document.getElementById("name") }, a = { w: parseInt("4500"), h: parseInt("4500"), foodCount: parseInt("1500"), virusCount: parseInt("10"), bots: parseInt("25") }, h = (e, o) => Math.random() * (o - e) + e, E = (e, o, t) => Math.max(o, Math.min(t, e)), d = { x: a.w / 2, y: a.h / 2, z: 1, targetZ: 1 }, M = new Map, L = new Map, m = new Map; let _ = 1, N = null; function b() { return _++ } function R(e) { N = e } function p() { return N } const $ = ["#ffffff", "#ff6b6b", "#4ecdc4", "#45b7d1", "#f9ca24", "#6c5ce7", "#a29bfe", "#fd79a8", "#fdcb6e", "#00b894", "#00cec9", "#0984e3", "#6c5ce7", "#e17055", "#fab1a0", "#ff7675", "#74b9ff", "#a29bfe", "#55efc4", "#ffeaa7"]; function U() { const e = b(); M.set(e, { id: e, x: h(0, a.w), y: h(0, a.h), r: h(2.2, 3.8), color: `hsl(${Math.floor(h(0, 360))} 90% 65%)` }) } function Z() { const e = b(); L.set(e, { id: e, x: h(0, a.w), y: h(0, a.h), r: 60 + h(-4, 4), angle: h(0, Math.PI * 2) }) } let P = new Set; function A(e, o = !1, t = null, n = "#ffffff") { const s = b(); let r = n; if (o) { const f = $.filter(u => !P.has(u)); f.length === 0 && (P.clear(), f.push(...$)), r = f[Math.floor(Math.random() * f.length)], P.add(r) } const c = { id: s, name: e, isBot: o, color: o ? `hsl(${Math.floor(h(0, 360))} 65% 55%)` : t || "#6ae388", borderColor: r, cells: [], score: 0, alive: !0, target: { x: h(0, a.w), y: h(0, a.h) }, mergeCooldown: 0 }; return c.cells.push({ id: b(), x: h(a.w * .25, a.w * .75), y: h(a.h * .25, a.h * .75), r: 25, vx: 0, vy: 0, color: c.color, borderColor: c.borderColor }), m.set(s, c), c } function ee() { M.clear(), L.clear(), m.clear(); for (let e = 0; e < a.foodCount; e++)U(); for (let e = 0; e < a.virusCount; e++)Z() } const w = { x: k / 2, y: j / 2 }; window.addEventListener("mousemove", e => { w.x = e.clientX, w.y = e.clientY }); y.playBtn.addEventListener("click", () => { const e = (y.nameInput.value || "Jogador").trim().slice(0, 16); oe(e) }); y.nameInput.addEventListener("keydown", e => { e.key === "Enter" && y.playBtn.click() }); window.addEventListener("keydown", e => { if (e.key.toLowerCase() === "w") { const o = p(); o && o.alive && o.cells.length > 0 && se(o) } }); window.addEventListener("keydown", e => { if (e.code === "Space") { const o = p(); o && o.alive && o.cells.length > 0 && J(o) } }); function te(e) { const o = [], t = Math.min(e, 20); for (let n = 1; n <= t; n++)o.push("bot " + n); return o } function oe(e) { if (p() && p().alive) return; y.joinEl.style.display = "none"; const o = A(e, !1, y.selectedColor, y.selectedBorderColor), t = K(o.cells[0].r); o.cells[0].x = t.x, o.cells[0].y = t.y, R(o) } const g = e => e * e, C = e => Math.sqrt(e); function ne(e, o) { for (const t of e.cells) { let n, s; if (e === p()) { n = (w.x - window.innerWidth / 2) / d.z + d.x, s = (w.y - window.innerHeight / 2) / d.z + d.y; const c = n - t.x, f = s - t.y, u = Math.hypot(c, f), S = Math.min(1.5, Math.max(.2, u / 100)), D = Math.atan2(f, c), G = 3e3, Q = 1 / (t.r * .01 + 1), q = (G * Q + 200) * S; t.vx += Math.cos(D) * q * o, t.vy += Math.sin(D) * q * o } else if (e.isBot) { Math.random() < .01 && (e.target.x = E(e.target.x + (Math.random() - .5) * 800, 0, a.w), e.target.y = E(e.target.y + (Math.random() - .5) * 800, 0, a.h)), n = e.target.x, s = e.target.y; const c = Math.atan2(s - t.y, n - t.x), f = 4500, u = 1 / (t.r * .01 + 1), x = f * u + 200; t.vx += Math.cos(c) * x * o, t.vy += Math.sin(c) * x * o } else n = t.x, s = t.y; t.vx *= .85, t.vy *= .85, t.x += t.vx * o, t.y += t.vy * o; const r = t.r; t.x = E(t.x, r, a.w - r), t.y = E(t.y, r, a.h - r) } if (e.mergeCooldown > 0) { e.mergeCooldown -= o; for (let t = 0; t < e.cells.length; t++)for (let n = t + 1; n < e.cells.length; n++) { const s = e.cells[t], r = e.cells[n], c = r.x - s.x, f = r.y - s.y, u = Math.hypot(c, f), x = s.r + r.r; if (u < x && u > .01) { const i = (x - u) / u, v = c * i * .5, S = f * i * .5; s.x -= v, s.y -= S, r.x += v, r.y += S } } } else for (let t = 0; t < e.cells.length; t++)for (let n = t + 1; n < e.cells.length; n++) { const s = e.cells[t], r = e.cells[n]; if (Math.hypot(s.x - r.x, s.y - r.y) < Math.min(s.r, r.r)) { const f = g(s.r) + g(r.r); s.r = C(f), s.vx = (s.vx + r.vx) * .5, s.vy = (s.vy + r.vy) * .5, e.cells.splice(n, 1), n-- } } } function I(e) { return e.cells.reduce((o, t) => o + g(t.r), 0) } function J(e) { const t = []; for (const s of e.cells) g(s.r) >= 200 && e.cells.length + t.length < 16 && t.push(s); for (const s of t) { const r = g(s.r) / 2; s.r = C(r); const c = (w.x - window.innerWidth / 2) / d.z + d.x, f = (w.y - window.innerHeight / 2) / d.z + d.y, u = Math.atan2(f - s.y, c - s.x), x = s.r * 2, i = 800; e.cells.push({ id: b(), x: s.x + Math.cos(u) * x, y: s.y + Math.sin(u) * x, r: C(r), vx: Math.cos(u) * i, vy: Math.sin(u) * i, color: e.color, borderColor: e.borderColor }) } const n = I(e); e.mergeCooldown = Math.min(19, 3 + n / 500) } function se(e) { for (const n of e.cells) { const s = g(n.r); if (s <= 430) continue; const r = s - 30; n.r = C(r); const c = Math.atan2(w.y - window.innerHeight / 2, w.x - window.innerWidth / 2), f = b(); M.set(f, { id: f, x: n.x + Math.cos(c) * (n.r + 5), y: n.y + Math.sin(c) * (n.r + 5), r: C(30), color: "#ff6666", isEjected: !0, mass: 30, vx: Math.cos(c) * 600, vy: Math.sin(c) * 600 }) } } let F = null; function K(e) { let o = 0; for (; o < 200;) { const t = Math.random() * a.w, n = Math.random() * a.h; let s = !0; for (const r of m.values()) { for (const c of r.cells) { const f = c.x - t, u = c.y - n; if (Math.hypot(f, u) < c.r + e + 100) { s = !1; break } } if (!s) break } if (s) return { x: t, y: n }; o++ } return { x: Math.random() * a.w, y: Math.random() * a.h } } function re(e) { const o = []; for (const [t, n] of m.entries()) n.isBot && !n.alive && n.respawnAt && n.respawnAt <= e && o.push({ id: t, name: n.name, color: n.color }); for (const t of o) { m.delete(t.id); const n = A(t.name, !0, t.color, t.borderColor || "#ffffff"), s = K(n.cells[0].r); n.cells[0].x = s.x, n.cells[0].y = s.y, n.alive = !0, n.mergeCooldown = 2, m.set(n.id, n) } } function le() { const e = p(); e && (e.alive = !1, e.cells = [], m.delete(e.id), y.joinEl.style.display = "flex", F && clearTimeout(F), R(null), F = null) } function ce() { for (const e of [...M.values()]) for (const o of m.values()) for (const t of o.cells) if (Math.hypot(e.x - t.x, e.y - t.y) < t.r) { const s = e.isEjected ? e.mass * .8 : g(e.r); t.r = C(g(t.r) + s), M.delete(e.id), e.isEjected || U() } for (const e of [...L.values()]) for (const o of m.values()) for (const t of o.cells) Math.hypot(e.x - t.x, e.y - t.y) < t.r - 10 && (J(o), L.delete(e.id), Z()); for (const e of m.values()) for (const o of m.values()) if (!(e === o || !e.alive || !o.alive)) for (const t of e.cells) for (const n of o.cells) Math.hypot(t.x - n.x, t.y - n.y) < t.r && t.r > n.r * 1.15 && (t.r = C(g(t.r) + g(n.r)), o.cells.splice(o.cells.indexOf(n), 1), o.cells.length === 0 && (o.alive = !1, o.isBot && !o.respawnAt && (o.respawnAt = performance.now() + 1500))) } const T = new Image; T.src = "src/assets/img/virus1.png"; let V = !1; T.onload = () => { V = !0 }; function ae() { l.fillStyle = "#111", l.fillRect(0, 0, k, j), l.save(), l.translate(k / 2, j / 2), l.scale(d.z, d.z), l.translate(-d.x, -d.y), l.strokeStyle = "#333"; for (let e = 0; e < a.w; e += 100)l.beginPath(), l.moveTo(e, 0), l.lineTo(e, a.h), l.stroke(); for (let e = 0; e < a.h; e += 100)l.beginPath(), l.moveTo(0, e), l.lineTo(a.w, e), l.stroke(); for (const e of M.values()) l.fillStyle = e.color, l.beginPath(), l.arc(e.x, e.y, e.r, 0, H), l.fill(); if (V) for (const e of L.values()) "angle" in e || (e.angle = 0), e.angle += .005, l.save(), l.translate(e.x, e.y), l.rotate(e.angle), l.drawImage(T, -e.r, -e.r, e.r * 2, e.r * 2), l.restore(); for (const e of m.values()) { if (!e.alive) continue; for (const t of e.cells) l.beginPath(), l.arc(t.x, t.y, t.r, 0, H), l.fillStyle = e.color, l.fill(), t.borderColor && (l.lineWidth = Math.min(3, Math.max(1, t.r * .05)), l.strokeStyle = t.borderColor, l.stroke()); const o = e.cells[0]; o && (l.fillStyle = "#fff", l.font = `${Math.max(12, o.r * .5)}px sans-serif`, l.textAlign = "center", l.fillText(e.name, o.x, o.y + o.r + 20)) } l.restore() } function ie() { const e = p(); e && (e.score = Math.floor(I(e))), y.scoreEl.textContent = e ? `Score: ${e.score}` : "Score: -"; const o = [...m.values()].filter(t => t.alive).sort((t, n) => I(n) - I(t)).slice(0, 10); y.lbEl.innerHTML = o.map((t, n) => `${n + 1}. ${t.name || "(no name)"} (${Math.floor(I(t))})`).join("<br>") } y.selectedColor = "#6ae388"; y.selectedBorderColor = "#ffffff"; document.addEventListener("DOMContentLoaded", () => { const e = document.querySelectorAll("#cellColorOptions .color-circle"), o = document.getElementById("cellCustomCircle"), t = document.getElementById("cellCustomColor"), n = document.getElementById("cellSelectedColorDisplay"); function s(i) { y.selectedColor = i, n.style.background = i } e.forEach(i => { i !== o && i.addEventListener("click", () => { e.forEach(v => v.classList.remove("selected")), i.classList.add("selected"), s(i.dataset.color) }) }), o.addEventListener("click", () => t.click()), t.addEventListener("input", i => { e.forEach(v => v.classList.remove("selected")), o.classList.add("selected"), s(i.target.value) }); const r = document.querySelectorAll("#borderColorOptions .color-circle"), c = document.getElementById("borderCustomCircle"), f = document.getElementById("borderCustomColor"), u = document.getElementById("borderSelectedColorDisplay"); function x(i) { y.selectedBorderColor = i, u.style.background = i } r.forEach(i => { i !== c && i.addEventListener("click", () => { r.forEach(v => v.classList.remove("selected")), i.classList.add("selected"), x(i.dataset.color) }) }), c.addEventListener("click", () => f.click()), f.addEventListener("input", i => { r.forEach(v => v.classList.remove("selected")), c.classList.add("selected"), x(i.target.value) }) }); let W = performance.now(), z = 0, O = 0; function X(e) { const o = (e - W) / 1e3; W = e; for (const n of m.values()) n.alive && ne(n, o); ce(); for (const n of M.values()) n.isEjected && (n.x += n.vx * o, n.y += n.vy * o, n.vx *= .9, n.vy *= .9); re(performance.now()); const t = p(); if (t && t.cells.length > 0) { const n = t.cells[0]; d.x += (n.x - d.x) * .1, d.y += (n.y - d.y) * .1, d.targetZ = E(1.5 - n.r / 500, .3, 1.5), d.z += (d.targetZ - d.z) * .1 } t && t.cells.length === 0 && le(), ae(), ie(), z++, O += o, O >= 1 && (document.getElementById("fps").textContent = `FPS: ${z}`, z = 0, O = 0), requestAnimationFrame(X) } ee(); const Y = Math.min(a.bots, 20), fe = te(Y); for (let e = 0; e < Y; e++)A(fe[e], !0); requestAnimationFrame(X);
